# Worksheet for Search Algorhtms Problems
## Q1: DFS, BFS, UCS

<img src="C:\Users\yhb\MscProject\AI&TA\AI\images\img_15.png">

1.Depth First Search (DFS)
A-->B-->D-->F-->K-->back to F-->L-->back to F-->back to D-->back to B-->E-->back to B-->back to A-->C-->G

2.Breadth First Search (BFS)
A-->B-->C-->D-->E-->G

3.Uniform Cost Search (UCS)
使用均匀成本搜索（Uniform Cost Search, UCS），搜索的具体过程如下：

1. 从起始节点A开始，目前的累积成本为0。
2. 扩展节点A的子节点B和C，它们的累积成本分别为A到B（成本1）和A到C（成本3）。
3. 下一步，选择累积成本最小的节点，这里是B（成本1）。
4. 然后，从B出发，扩展子节点D和E，它们的累积成本分别是A-B-D（成本2）和A-B-E（成本2）。由于成本相同，按照字母顺序，D和E将被放入待扩展队列。
5. 然而，在D和E被扩展之前，我们先扩展了C，因为C的成本（3）小于D和F的成本（均为3）。
6. 从C出发，我们可以直接到达G，此时累积成本为A-C-G（成本4），因为G是目标节点，搜索到此结束。

所以，UCS的具体扩展过程为：A -> C -> G。到达G后搜索停止，总成本为4。

### Q2: Water Jug Problem--BFS or DFS
<img src="C:\Users\yhb\MscProject\AI&TA\AI\images\img_17.png">

这是关于水桶问题的：

问题2. 考虑水桶问题。你有一个水龙头，一个5升的桶和一个7升的桶。你需要精确地得到4升水。你可以从水龙头或另一个桶中向任一桶中灌水；你也可以将任一桶中的水倒入排水口或另一个桶中。
(i) 当小桶中有S升水，大桶中有L升水时，可能的动作有哪些？
(ii) 从初始状态（0，0）开始，画出搜索树，直到你到达一个目标节点，在两个桶中的一个里有4升水。
(iii) 为了找到最优解，广度优先搜索还是深度优先搜索更好？为什么？

问题3是问(iii)部分。

接下来我将回答这些问题。

(i) 对于小桶（5升桶）和大桶（7升桶），可能的动作包括：
- 从水龙头填满任一桶（如果它们不是满的）。
- 将任一桶中的水全部倒掉（如果它们不是空的）。
- 将一个桶中的水倒入另一个桶，直到被倒入的桶满或倒出的桶空。
- 如果小桶中有S升水，大桶中有L升水，可以将S升水倒入大桶中，只要L+S≤7。
- 如果大桶中有L升水，小桶中有S升水，可以将L升水倒入小桶中，只要S+L≤5。

(ii) 搜索树较为复杂，涉及多个状态和转换，下面描述一个可能的路径到达目标状态：
1. 初始状态(0,0)。
2. 填满7升桶（0,7）。
3. 将7升桶中的水倒入5升桶，直到5升桶满（5,2）。
4. 清空5升桶（0,2）。
5. 将7升桶中剩余的2升水倒入5升桶（2,0）。
6. 再次填满7升桶（2,7）。
7. 将7升桶中的水倒入5升桶，直到5升桶满（5,4）。
到这里，我们已经在7升桶中得到了4升水，达成了目标。

(iii) 为了找到最优解，广度优先搜索（BFS）通常更好。因为在水桶问题中，我们通常不知道解的深度，BFS可以按层次搜索所有状态，从而保证找到的第一个解是最优解。相反，深度优先搜索（DFS）可能会沿着一个不是最优解的路径深入搜索，导致找到的第一个解可能不是最优的。此外，BFS在水桶问题中更有优势，因为它可以在不太深的层次中找到解，而DFS可能会不必要地深入很多层。
## Q3: Greedy Best First Search

<img src="C:\Users\yhb\MscProject\AI&TA\AI\images\img_18.png">

这个问题是关于启发式搜索的：

问题3. 下面是一个要搜索的图（从节点S到节点G）。你得到了一系列各状态的启发式估计值。

A=2
B=3
C=1
D=4
S=10
G=0

在字母顺序下打破平局。

执行一个最佳优先贪婪搜索。展示通往目标的路径。

为了回答这个问题，我们首先需要理解最佳优先贪婪搜索（又称贪婪搜索）。在这种搜索中，我们选择启发式值（即到目标节点的估计成本）最低的节点作为搜索路径的下一步。这里给出的启发式值是从各个节点到目标节点G的估计成本。贪婪搜索不考虑已经走过的路径的成本，只考虑从当前节点到目标节点的启发式成本。

下面是根据给出的启发式值和图进行贪婪搜索的过程：

1. 从起始节点S开始，启发式值为10。
2. 查看S的相邻节点A和B，它们的启发式值分别为A=2和B=3。根据贪婪最佳优先搜索策略，我们选择启发式值最小的节点，这里是节点A。
3. 从节点A，我们可以去节点D（启发式值为4），因为从A到C的路径不存在，而A到G的直接路径也不存在，所以我们选择了唯一可行的选项。
4. 从节点D，我们可以直接到达目标G（启发式值为0），因为D到G有一条路径。

所以，贪婪最佳优先搜索的路径是 S -> A -> D -> G。总成本为10+2+4=16。

由于采用贪婪算法，只保证每一步为局部最优，但不保证最终路径为全局最优。在这个例子中，贪婪搜索找到的路径不是最优路径，最优
路径应该为：S -> B -> G，总成本为10+3=13。

## Q4: A Star Search

这个问题是关于A*搜索算法的：

问题4. 我们给定了下图，每个节点都有一个标识符和启发式值，每条边都有一个代价。

<img src="C:\Users\yhb\MscProject\AI&TA\AI\images\img_19.png">

问题4a 展示从S到G（目标节点）A*搜索看到的节点顺序。在搜索过程中对于每个节点展示其f和g值。如果一个节点通过多条路径到达，每到达一次就展示其f和g值，并标明其父节点。

基于您给出的图定义和启发式（h）函数值，我们可以详细描述A*搜索算法从A到G的搜索过程如下：

1. **开始**：从节点A开始搜索。A的g成本（从起始点到当前点的实际成本）为0，h成本（启发式估计到目标G的成本）为10，所以A的f成本（g+h）也是10。

2. **扩展A**：查看A的所有邻居（B，C，D），并计算它们的成本：
   - 到B的实际成本是A到B的成本2加上A的g成本0，所以B的g成本是2。B的h成本是12，所以B的f成本是2+12=14。
   - 到C的实际成本是A到C的成本6加上A的g成本0，所以C的g成本是6。C的h成本是6，所以C的f成本是6+6=12。
   - 到D的实际成本是A到D的成本10加上A的g成本0，所以D的g成本是10。D的h成本是1，所以D的f成本是10+1=11。

   将B，C，D添加到开放列表中。

3. **选择下一个节点**：从开放列表中选择具有最低f成本的节点。此时，D的f成本最低，为11，所以接下来扩展D。

4. **扩展D**：查看D的邻居F：
   - 到F的实际成本是D到F的成本2加上D的g成本10，所以F的g成本是12。F的h成本是1，所以F的f成本是12+1=13。

   将F添加到开放列表中。

5. **选择下一个节点**：此时，从开放列表（B, C, F）中选择具有最低f成本的节点。C的f成本最低，为12，所以接下来扩展C。

6. **扩展C**：查看C的邻居G：
   - 到G的实际成本是C到G的成本20加上C的g成本6，所以G的g成本是26。G的h成本是0（因为它是目标），所以G的f成本是26+0=26。

   将G添加到开放列表中。

7. **选择下一个节点**：此时，开放列表中有B, F, G。尽管G是目标节点，但它的f成本不是最低的。因此，我们接下来扩展B（f成本为14）。

8. **扩展B**：查看B的邻居E：
   - 到E的实际成本是B到E的成本10加上B的g成本2，所以E的g成本是12。E的h成本是1，所以E的f成本是12+1=13。

   将E添加到开放列表中。

9. **选择下一个节点**：此时，开放列表中有F, G, E。E的f成本最低，为13，所以接下来扩展E。

10. **扩展E**：查看E的邻居G：
    - 到G的实际成本是E到G的成本2加上E的g成本12，所以G的g成本更新为14（之前是26，现在更低）。G的h成本是0，所以G的f成本更新为14。

    由于G现在是开放列表中f成本最低的节点，且它是目标节点，搜索结束。

最终路径为A -> B -> E -> G，总成本为A到B的2，B到E的10，加上E到G的2，总计14。

问题4b 找到的解决路径是什么？

问题4c 启发式函数h是否可接受？它是否一致？

问题4d 假设你决定使用以下评估函数进行最佳优先搜索：
f(n) = (1 − w)g(n) + wh(n)
假设h(n)是可接受的，保证算法找到最优解的w值是多少？

